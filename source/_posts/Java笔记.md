---
title: Java笔记
date: 2022-01-15 15:55:50
tags: Java
categories: 
    - Java
---

# 2021.12.7
## **堆内存和栈内存**
Java把内存分成两种，一种叫做栈内存，一种叫做堆内存
- **栈内存：**在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的**栈内存**中分配
- **堆内存：**用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量。
**创建一个对象new运算符：**
new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。

## **String、StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?**
**可变性：**
简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，所以String 对象是不可变的。
**总结：**

1. 操作少量的数据: 适用 String
2. 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer

## **深拷贝和浅拷贝区别了解吗？什么是引用拷贝？**
- **浅拷贝：** 浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，**如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址**，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝 ：** 深拷贝会**完全复制**整个对象，包括这个对象所包含的内部对象。
- **引用拷贝：** 引用拷贝就是两个不同的引用指向同一个对象。

## **反射机制：**
**优缺点：**
- **优点 ：** 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利
- **缺点 ：** 让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。

# 2021.12.8
## **异常**
在 Java 中，所有的异常都有一个共同的祖先 Throwable 类。Throwable 类有两个重要的子类 Exception（异常）和 Error（错误）。Exception 能被程序本身处理(try-catch)， Error 是无法处理的(只能尽量避免)。
- **Exception ：** 程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 受检查异常(必须处理) 和 不受检查异常(可以不处理)。
- **Error ：** Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。例如，Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。
受检查异常：如果受检查异常没有被 catch/throw 处理的话，就没办法通过编译 。如IO操作。
- **不受检查异常：** 即使不处理不受检查异常也可以正常通过编译。
- **try-catch-finally：** finally 块无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。

# 2021.12.28
## JVM相关
**JVM：** Java虚拟机
**JRE：** JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。
**JDK：** JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。

## **包装类型的常量池技术**
Java 基本类型的包装类的大部分都实现了常量池技术
**Byte,Short,Integer,Long** 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据。
**Character** 创建了数值在 [0,127] 范围的缓存数据。
**Boolean** 直接返回 True or False。
两种浮点数类型的包装类 **Float,Double** 并没有实现常量池技术。
所有整型包装类对象之间值的比较，全部使用 equals 方法比较（例：对于Integer在-128到127的值可以用==来比较，因为会用到常量池）

## **自动装箱与拆箱**
- **装箱：** 将基本类型用它们对应的引用类型包装起来；
- **拆箱：** 将包装类型转换为基本数据类型；
例：
```
Integer i = 10;  //装箱
int n = i;   //拆箱
```


## **I/O 流**
**什么是序列化?什么是反序列化?**
如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。
- **序列化：** 将数据结构或对象转换成二进制字节流的过程
- **反序列化：** 将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

# 2021.1.4
## **堆** PriorityQueue
```java
A = new PriorityQueue<>(); // 小顶堆
B = new PriorityQueue<>((x, y) -> (y - x)); // 大顶堆
```

## **容器**
![](https://carbda-bucket.oss-cn-hangzhou.aliyuncs.com/img/java1.png)

一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法

### **List**
ArrayList和Vector：
- Vector线程安全（古老实现类）、ArrayList线程不安全（主要实现类）

ArrayList和LinkedList：
- ArrayList底层是数组，LinkedList底层是双向链表

### **Set**
HashSet、LinkedHashSet 和 TreeSet：
- 都是Set的实现类
- HashSet 底层是哈希表（基于HashMap实现）、LinkedHashSet 底层是链表和哈希表、TreeSet 底层是红黑树

### **Queue**
Queue 与 Deque 的区别：
- Queue是单端队列，Deque是双端队列

### **Deque**
ArrayDeque 与 LinkedList 的区别：
- ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。
- ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持。

### **PriorityQueue**（默认是小顶堆）
- 与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。
- PriorityQueue 默认是小顶堆，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。

### **Map**
HashMap 和 Hashtable 的区别：
- HashMap 是非线程安全的，Hashtable 是线程安全的
- 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。（HashSet基本被淘汰）
- HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个

HashMap 和 HashSet 区别：
- HashSet 底层就是基于 HashMap 实现的。

**HashSet** 如何检查重复：

- 当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。

总结：先判断hashcode是否有重复，再用equal()判断是否重复

### **== 与 equals 的区别：**
- 对于基本类型来说，== 比较的是值是否相等；
- 对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；

### HashMap 的底层实现：
JDK1.8 之前：
- HashMap 底层是 数组和链表 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。

JDK1.8 之后：
- 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。

# 2021.1.5
## 为什么重写 equals() 时必须重写 hashCode() 方法？
因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。 如果重写 equals() 时没有重写 hashCode() 方法的话就可能会导致 equals 方法判断是相等的两个对象，hashCode 值却不相等。

## 线程的创建方式有几种？
1. 继承Thread类创建线程
2. 实现Runnable接口创建线程
3. 使用Callable和Future创建线程
4. 使用线程池例如用Executor框架

**Runnable 接口和 Callable 接口的区别**
- Runnable 接口 不会返回结果或抛出检查异常，但是 Callable 接口 可以。

**线程池：**
**ThreadPoolExecutor构造函数重要参数分析：**
3 个最重要的**参数**：
- **corePoolSize**：核心线程数定义了最小可以同时运行的线程数量。
- **maximumPoolSize**：当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- **workQueue**：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

其他常见参数：
- keepAliveTime：当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了
- keepAliveTime才会被回收销毁； 
- unit：keepAliveTime 参数的时间单位。 
- threadFactory：executor 创建新线程的时候会用到。 
- handler：拒绝策略（如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时的策略）

**顺序：**
1. corePoolSize
2. maximumPoolSize 
3. keepAliveTime
4. unit
5. workQueue
6. threadFactory
7. handler

## Java文件加载过程
如图
<img src="https://carbda-bucket.oss-cn-hangzhou.aliyuncs.com/img/java2.png" style="zoom:80%;" />

.java先经过编译成.class文件，之后经过解释器的解释执行，成为机器可理解的机器码，之后机器码被OS执行。

## 堆和方法区
堆和方法区是所有线程共享的资源。
- **堆：** 是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)
- **方法区：** 主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

## 并发与并行的区别
- **并发：** 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；
- **并行：** 单位时间内，多个任务同时执行。

## 线程间通信的几种实现方式
**方式一：** 使用 **volatile** 关键字：
- 基于 volatile 关键字来实现线程间相互通信是使用共享内存的思想，大致意思就是多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。

**方式二：** 使用Object类的**wait()** 和 **notify()** 方法：

- 配合 **synchronized** 使用

**方式三：** 使用 JUC 工具类 CountDownLatch：

- CountDownLatch底层基于AQS框架，也是维护了一个线程间共享变量 state 实现的。

**方式四：** 使用 LockSupport：

- LockSupport 是一种非常灵活的实现线程间阻塞和唤醒的工具，使用它可以不关注是唤醒线程先运行还是等待线程先运行，但是得知道线程的名字。

# 2022.1.6

## new String("aa")创建几个对象？
应该2个？（new方法在堆里创建了一个string对象，并且在常量池创建了一个string对象）
1. 直接赋值形式的新建string对象是从常量池中拿数据；最多创建一个string对象，虽少创建0个string对象；
2. new形式新建string对象无论怎样会首先在堆内存中创建一个string对象，然后确保常量池中也有一个相同内容的string对象；最多创建2个，最少创建1个。

## 如何减少上下文切换？
减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。
**无锁并发编程：** 多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一
些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。
**CAS算法：** Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
**使用最少线程：** 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这
样会造成大量线程都处于等待状态。
**协程：** 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

# 2022.2.22
## 面向对象的三大特征
1. **封装**
封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。
2. **继承**
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。
3. **多态**
顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。

**多态的特点：**
- 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；
- 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
- 多态不能调用“只在子类存在但在父类不存在”的方法；
- 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法

## 字符串常量
**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。
```java
String aa = "ab"; // 放在常量池中
String bb = "ab"; // 从常量池中查找
System.out.println(aa==bb);// true
```
JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区。JDK1.7 的时候，字符串常量池被从方法区拿到了堆中。

# 2022.3.7
## Java 并发
**线程与进程：**
与进程不同的是同类的多个线程共享进程的**堆**和**方法区资源**，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**

# 2022.3.18
## 接口和抽象类有什么共同点和区别？
**共同点：**
- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法（Java 8 可以用 default 关键在接口中定义默认方法）。
**区别：**
- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

## RSA加密算法（非对称加密算法之一）：
```
公钥：（E，N）
密文 = 明文^E mod N
私钥：（D，N）
明文 = 密文^D mod N
```

# 2022.3.27
## JVM
**堆：** 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。
**方法区：** 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
以上二者都是是各个线程共享的内存区域。
**运行时常量池：** 运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）

## Java对象创建过程

![](https://carbda-bucket.oss-cn-hangzhou.aliyuncs.com/img/java3.png)

**类加载检查：**
虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过。如果没有，那必须先执行相应的类加载过程。
**分配内存：**
在类加载检查通过后，接下来虚拟机将为新生对象分配内存。
**初始化零值：**
内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
**设置对象头：**
初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。
**执行 init 方法：**
执行 new 指令之后会接着执行 ```<init>``` 方法，把对象按照程序员的意愿进行初始化

## 对象的内存布局
在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。
**对象头：** 包括两部分信息，第一部分用于存储**对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），另一部分是**类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
**实例数据：** 是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。
**对齐填充：** 不是必然存在的，也没有什么特别的含义，仅仅起占位作用。

## 对象的访问定位
目前主流的访问方式有 **使用句柄** 和 **直接指针** 两种
**使用句柄：** 如果使用句柄，那么 Java **堆**中将会划分出一块内存来作为**句柄池**，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息
**直接指针：** 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

# 2022.4.12
## ConcurrentHashMap底层
结构：**数组+链表**，数组**初始大小为16**
数组大小到64，链表长度到8会转红黑树，红黑树大小到6会退化回链表
如何保证并发安全：**对于Node节点加锁**
**性能优化：**
1、jdk1.8的粒度是Node节点，而jdk1.7的粒度是segment
2、用红黑树的复杂度是O(logn)，而用单向链表复杂度是O(n)
3、扩容时是多线程并发扩容，多个线程对于原始线程分片，每个线程负责一个分片的数据迁移
size()方法获取**总的元素个数**：
1、当线程竞争不激烈，直接用CAS的方式，实现元素个数的原子递增
2、当线程竞争激烈，使用一个数组来维护元素个数，要增加总原子个数时，直接从数组中随机选择一个，再通过CAS算法实现原子递增。

**JDK1.7：**用ReentrantLock给segment加锁，保证segment的线程安全

**JDK1.8：**锁的粒度不再是segment了，使用数组链表+红黑树（和HashMap差不多），当对空的数组项加入元素时用CAS的方式加入，若这个数组项上不为空，则使用synchronized加锁后再遍历里面的元素

## String 的 hashCode 是怎么计算的？
对于String里的char[] value数组，进行遍历，遍历的循环体为 h = h*31 + value[i]

## CAS算法
假设多个线程要对一个共享资源的值进行修改，会对于获取时的值保存为**old value**，在真正进行操作时要比对操作时共享资源的值是否为old value，如果是old value说明自己抢占到了这个资源，可以进行操作，如果不等于old value说明别的线程抢先一步进行操作了，那么需要**自旋**等待，重新获取old value再走一遍流程。如果一直失败，那么会放弃操作（Java里默认自旋10次）
但是CAS要是**原子性**的，同时只有一个线程在操作

CPU会原生的支持CAS

比如AtomicInteger类，在Java里用到了 Unsafe 类里的 getAndAddInt 方法，默认是自旋10次后放弃。

解决ABA问题：ABA问题的根源就是无法确认数据修改者的身份，因此可以通过过添加版本号的方式去解决，通过比较值再比较版本号的方式去判断其操作者，直到数据的版本号是操作者颁发的时候才有权利去修改，这样就可以解决ABA的问题。

## volatile 关键字
在当前的 Java 内存模型下，线程可以把变量保存**本地内存**（比如机器的寄存器）中，而不是直接在**主存**中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成**数据的不一致**。

把变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

## 并发编程的三个重要特性
**原子性：** 一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。synchronized 可以保证代码片段的原子性。

**可见性：** 当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。volatile 关键字可以保证共享变量的可见性。

**有序性：** 代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。volatile 关键字可以禁止指令进行重排序优化。

## Synchronized的原理
用到了 **Monitor** ，锁的获取和释放有 **monitorenter** 和 **monitorexit** 

可以看作加了锁后，线程获取锁就进入Monitor，其他线程要获取锁需要等待这个线程完成操作推出Monitor才可以进入。
也可能进入Monitor的线程要完成一些判断操作，进入wait set，这样其他线程会进入Monitor，其他线程执行好了之后会去notify原本的线程，让原本的线程再进入Monitor执行，执行完毕后退出。
Monitor 是依赖于操作系统的 mutex lock 来实现的。

Monitor中有两个队列， **WaitSet** 和 **EntryList**，当多个线程同时访问一段同步代码时：
- 首先会进入 **EntryList** 集合，当线程获取到对象的monitor后，进入 **Owner** 区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1；
- 若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 **WaitSet** 集合中等待被唤醒；
- 若当前线程执行完毕，也将释放monitor（锁）并复位count的值，以便其他线程进入获取monitor(锁)；

# 2022.4.13
## AQS的原理
有一个变量 state，state 初始值为0，有线程加锁时会用CAS的方式将 state 值加1，如果成功则加锁成功，失败了线程则会进入等待队列。
释放锁时会将 state 减1，减到0时锁释放。

AQS资源共享方式：
- **独占**：只有一个线程能执行，如ReentrantLock
- **共享**：不止一个线程能执行，如ReentrantWriteLock、Semaphore（信号量？）

独占方式分为：
- **公平锁**：按照线程在队列中的排队顺序，先到者先拿到锁
- **非公平锁**：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。

## 锁升级

锁在只有一个线程时会上一个**偏向锁**。
当不止一个线程在被锁管理时会升级为**轻量级锁**，这时没有获取锁的线程会自旋等待（通过CAS获取锁）。
当线程自旋次数超过了自旋默认次数（10次），那么会升级为**重量级锁**，这时候就用到了Monitor对于线程进行控制，管控最为严格。
网上：偏向锁是在无锁争用的情况下使用的，也就是同步开在当前线程没有执行完之前，没有其它线程会执行该同步块，一旦有了第二个线程的争用，偏向锁就会升级为轻量级锁，如果轻量级锁自旋到达阈值后，没有获取到锁，就会升级为重量级锁。

## 多态
**编译时多态：** 编译期间决定目标方法，同名不同参，通过重载实现
**运行时多态：** 运行时决定目标方法，同名同参，通过重写和继承实现，JVM决定目标方法

多态的实现机制：
- JVM方法区：里面存储有实例的方法
- invokeVirtual指令：用这个指令来调用方法
- 方法表（存放方法入口地址）：子类的方法如果重写了，方法表就指向子类实例，否则向上寻找指向父类实例

# 2022.4.14
## 垃圾回收机制（GC）
Java 堆是垃圾收集器管理的主要区域，也被称作 **GC堆**
Java 堆还可以细分为：**新生代**和**老年代**：再细致一点有：**Eden** 空间、**From Survivor**、**To Survivor** 空间等
**堆**的基本结构：
<img src="https://carbda-bucket.oss-cn-hangzhou.aliyuncs.com/img/java4.png"  />

### Minor GC
此时如果新生的对象无法在 Eden 区创建（Eden 区**无法容纳**) 就会触发一次 **Minor GC** 此时会将 S0 区与Eden 区的对象一起进行**可达性分析**，找出活跃的对象，将它复制到 S1 区并且将S0区域和 Eden 区的对象给清空，这样那些不可达的对象进行清除，并且将S0 区 和 S1区交换。并且对象的年龄还会加 1，当它的年龄增加到一定程度（默认为大于 15 岁），就会被晋升到老年代中。
**大对象**直接进入**老年代**，大对象就是需要大量连续内存空间的对象（比如：字符串、数组），这是为了避免为大对象分配内存时由于**分配担保机制**带来的复制而降低效率。

**分配担保机制：**
在发生Minor GC之前，虚拟机会先检查**老年代最大可用的连续空间是否大于新生代所有对象总空间**，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlerPromotionFailure这个参数设置的值(true或flase)**是否允许担保失败**(如果这个值为true，代表着JVM说，我允许在这种条件下尝试执行Minor GC，出了事我负责)。如果允许，那么会继续检查**老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小**，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlerPromotionFailure为false，那么这次Minor GC将升级为**Full GC**

### Major GC
发生在老年代的GC ，基本上发生了一次Major GC 就会发生一次 Minor GC。并且Major GC 的速度往往会比 Minor GC 慢 10 倍。

### 垃圾收集算法
- **标记-清除算法：** 该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。
- **标记-复制算法：** 将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。
- **标记-整理算法：** 标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
- **分代收集算法：** 当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。

比如在**新生代**中，每次收集都会有大量对象死去，所以可以选择 **“标记-复制”算法** ，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而**老年代**的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或 **“标记-整理”算法** 进行垃圾收集。

### 如何判断对象已经死亡？
**可达性分析：** 这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

**哪些对象可以作为 GC Roots 呢？**
- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

# 2022.4.16
## IO模型
### BIO
在此种方式下，**用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。** JAVA传统的IO模型属于此种方式！
服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。

### NIO
NIO 可以看作是 **I/O 多路复用模型**。
IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -> 用户空间）还是阻塞的。
**IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。**
Java 中的 NIO ，有一个非常重要的**选择器 ( Selector )** 的概念，也可以被称为 **多路复用器**。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。
在NIO此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。
服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
### AIO
在此种模式下，**用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知**，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。 
服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是有OS先完成了再通知服务器应用去启动线程进行处理。

### 总结
<img src="https://carbda-bucket.oss-cn-hangzhou.aliyuncs.com/img/java5.png" style="zoom:70%;" />

# 2022.4.17
## 类加载过程
Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？
**过程：**
![](https://carbda-bucket.oss-cn-hangzhou.aliyuncs.com/img/java6.png)

### 加载
1. 通过全类名获取定义此类的**二进制字节流**
2. 将字节流所代表的静态存储结构转换为**方法区的运行时数据结构**
3. 在内存中生成一个代表该类的 **Class 对象**，作为方法区这些数据的访问入口

### 验证
![](https://carbda-bucket.oss-cn-hangzhou.aliyuncs.com/img/java7.png)

确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查。

### 准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。
1. 这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 static 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。
2. 这里所设置的初始值"通常情况"下是数据类型默认的零值（如 0、0L、null、false 等）

### 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。
符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

### 初始化
初始化阶段是执行初始化方法 ```<clinit>()``` 方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

## 类加载器
JVM中提供了三层的**ClassLoader**：
1. **BootstrapClassLoader(启动类加载器) ：** 最顶层的加载类，由 C++实现，负责加载 %JAVA_HOME%/lib目录下的 jar 包和类或者被 -Xbootclasspath参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器) ：** 主要负责加载 %JRE_HOME%/lib/ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包。
3. **AppClassLoader(应用程序类加载器) ：** 面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

过程如下图：

<img src="https://carbda-bucket.oss-cn-hangzhou.aliyuncs.com/img/java8.png" style="zoom:60%;" />

当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先会在AppClassLoader中**检查是否加载过**，如果有那就无需再加载了。如果没有，那么会拿到**父加载器**，然后调用父加载器的**loadClass**方法。父类中同理也会先检查自己是否已经加载过，如果没有再往上。注意这个类似递归的过程，直到到达**BootstrapClassLoader**之前，都是在检查是否加载过，并不会选择自己去加载。直到BootstrapClassLoader，已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会**下沉**到**子加载器**去加载，一直到最底层，如果没有任何加载器能加载，就会抛出**ClassNotFoundException**。

**为什么要设计这种机制?**

这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被BootstrapClassLoader加载过了（为什么？因为当一个类需要加载的时候，**最先去尝试加载的就是BootstrapClassLoader**），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。

# 2022.4.18
## 哈夫曼编码
假如我们需要将字符串ABBBCCCCCCCCDDDDDDEE通过二进制编码进行传输
如下：

|   A   |   B   |   C   |   D   |   E   |
| :---: | :---: | :---: | :---: | :---: |
|   1   |   3   |   8   |   6   |   2   |


### 构建哈夫曼树
首先构建森林：
<img src="https://carbda-bucket.oss-cn-hangzhou.aliyuncs.com/img/java9.png" style="zoom:90%;" />
两棵根节点值最小的树进行合并，合并方式为生成一棵新树，且让两棵树作为新树的左右子树。将两棵树从森林删除，新树加入森林。
<img src="https://carbda-bucket.oss-cn-hangzhou.aliyuncs.com/img/java10.png" style="zoom:90%;" />
重复操作，直到森林只剩一棵树为止，该树即为哈夫曼树（顶上应该是20不是12)：
<img src="https://carbda-bucket.oss-cn-hangzhou.aliyuncs.com/img/java11.png" style="zoom:80%;" />

### 构建哈夫曼编码
此时哈夫曼树构建完成了，下面我们要对各个字母进行编码，编码原则是，从哈夫曼树的根节点开始，进入左子树则编码号加0，进入右子树则编码号加1，就可以得到对应字母的二进制编码。
<img src="https://carbda-bucket.oss-cn-hangzhou.aliyuncs.com/img/java12.png" style="zoom:80%;" />
各个字母的编码如下：

|   A   |   B   |   C   |   D   |   E   |
| :---: | :---: | :---: | :---: | :---: |
| 1110  |  110  |   0   |  10   | 1111  |

此时字符串：ABBBCCCCCCCCDDDDDDEE的哈夫曼编码是1110110110110000000001010101010101111，显然编码比之前短了。

### 问题总结
1. **为什么通过哈夫曼编码后得到的二进制码不会有前缀的问题呢？**
这是因为在哈夫曼树中，每个字母对应的节点都是叶子节点，而他们对应的二进制码是由根节点到各自节点的路径所决定的，正因为是叶子节点，每个节点的路径不可能和其他节点有前缀的关系。
（我的理解：由树的结构可以看出来只有一个右叶子节点和 n-1 个左叶子节点，因此可以很容易分析出当前位是否是字母编码的最后一位）
2. **为什么通过哈夫曼编码获得的二进制码短呢？**
因为哈夫曼树是带权路径长度最短的树，权值较大的节点离根节点较近。而带权路径长度是指：树中所有的叶子节点的权值乘上其到根节点的路径长度，这与最终的哈夫曼编码总长度成正比关系的。

# 2022.8.18

## ThreadLocal

通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。**如果想实现每一个线程都有自己的专属本地变量该如何解决呢？** JDK 中提供的 **ThreadLocal** 类正是为了解决这样的问题。主要解决的就是**让每个线程绑定自己的值**，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。

如果你创建了一个 **ThreadLocal** 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 **ThreadLocal** 变量名的由来。他们可以使用 `get()` 和 `set()` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。

## 代理

简单来说就是：我们使用代理对象来代替对真实对象的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。

代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。

个人理解：不直接访问真实对象，而是去访问代理对象，代理对象会对于真实对象的方法调用进行处理

### 静态代理

静态代理中，**我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类）**。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。

上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。

静态代理实现步骤:

1. 定义一个接口及其实现类；
2. 创建一个代理类同样实现这个接口
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。

### 动态代理

相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( *CGLIB 动态代理机制*)。

**从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。**

动态代理的实现方式有很多种，比如 **JDK 动态代理**、**CGLIB 动态代理**等等。

#### JDK动态代理

1. 定义一个接口及其实现类；

2. 自定义 **InvocationHandler** 并重写 **`invoke`** 方法，在 `invoke` 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；

3. 通过 **`Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)`** 方法创建代理对象；

**`invoke()`** 方法有下面三个参数：

1. **proxy** :动态生成的代理类
2. **method** : 与代理类对象调用的方法相对应
3. **args** : 当前 method 方法的参数

也就是说：**你通过`Proxy` 类的 `newProxyInstance()` 创建的代理对象在调用方法的时候，实际会调用到实现`InvocationHandler` 接口的类的 `invoke()`方法。** 你可以在 `invoke()` 方法中自定义处理逻辑，比如在方法执行前后做什么事情。

#### CGLIB代理

**CGLIB** 动态代理通过继承实现。如果目标类**没有实现接口**，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。

CGLIB 可以在运行时动态生成类的字节码，**动态创建目标类的子类对象，在子类对象中增强目标类。**

**优点**：目标类不需要实现特定的接口，更加灵活。

## 泛型

泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。

```java
List<Integer> list = new ArrayList<>();

list.add(12);
//这里直接添加会报错
list.add("a");
Class<? extends List> clazz = list.getClass();
Method add = clazz.getDeclaredMethod("add", Object.class);
//但是通过反射添加是可以的
//这就说明在运行期间所有的泛型信息都会被擦掉
add.invoke(list, "kl");
System.out.println(list);
```

泛型一般有三种使用方式: 泛型类、泛型接口、泛型方法。

**泛型类：**

```java
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic<T> {
    private T key;
    public Generic(T key) {
        this.key = key;
    }
    public T getKey() {
        return key;
    }
}
```

如何实例化泛型类：

```java
Generic<Integer> genericInteger = new Generic<Integer>(123456);
```

**泛型接口：** 

```java
public interface Generator<T> {
    public T method();
}
```

实现泛型接口，不指定类型：

```java
class GeneratorImpl<T> implements Generator<T>{
    @Override
    public T method() {
        return null;
    }
}
```

实现泛型接口，指定类型：

```java
class GeneratorImpl implements Generator<String>{
    @Override
    public String method() {
        return "hello";
    }
}
```

**泛型方法：**

```java
public static <E> void printArray(E[] inputArray) {
    for (E element : inputArray) {
        System.out.printf("%s ", element);
    }
    System.out.println();
}
```

使用：

```java
// 创建不同类型数组： Integer, Double 和 Character
Integer[] intArray = { 1, 2, 3 };
String[] stringArray = { "Hello", "World" };
printArray(intArray);
printArray(stringArray);
```
